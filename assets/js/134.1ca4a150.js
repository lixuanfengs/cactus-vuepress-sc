(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{484:function(t,e,a){"use strict";a.r(e);var n=a(0),v=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("注：我对原文进行了格式规范和内容完善。")]),t._v(" "),e("p",[t._v("原文地址：https://www.javadoop.com/post/netty-part-1")]),t._v(" "),e("p",[t._v("作者：JavaDoop")]),t._v(" "),e("p",[t._v("本文将介绍 Netty，Java 平台上使用最广泛的 NIO 包，它是对 JDK 中的 NIO 实现的一层封装，让我们能更方便地开发 NIO 程序。其实，Netty 不仅仅是 NIO 吧，但是，基本上大家都冲着 NIO 来的。")]),t._v(" "),e("p",[t._v("个人感觉国内对于 Netty 的吹嘘是有点过了，主要是很多人靠它吃饭，要么是搞培训的，要么是出书的，恨不得把 Netty 吹上天去，这种现象也是挺不好的，反而使得初学者觉得 Netty 是什么高深的技术一样。")]),t._v(" "),e("p",[t._v("Netty 的源码不是很简单，因为它比较多，而且各个类之间的关系错综复杂，很多人说它的源码很好，这点我觉得一般，真要说好代码，还得 Doug Lea 的并发源码比较漂亮，一行行都是精华，不过它们是不同类型的，也没什么好对比的。Netty 源码好就好在它的接口使用比较灵活，往往接口好用的框架，源码都不会太简单。")]),t._v(" "),e("p",[t._v("本文将立足于源码分析，所以读者需要先掌握 NIO 的基础知识，至少我之前写的 "),e("a",{attrs:{href:"https://www.javadoop.com/post/java-nio",target:"_blank",rel:"noopener noreferrer"}},[t._v("《Java NIO：Buffer、Channel 和 Selector》"),e("OutboundLink")],1),t._v(" 中介绍的基础知识要清楚，如果读者已经对 Netty 有些了解，或者使用过，那就更好了。")]),t._v(" "),e("ul",[e("li",[t._v("本文只介绍 TCP 相关的内容，Netty 对于其他协议的支持，不在本文的讨论范围内。")]),t._v(" "),e("li",[t._v("和并发包的源码分析不一样，我不可能一行一行源码说，所以有些异常分支是会直接略过，除非我觉得需要介绍。")]),t._v(" "),e("li",[t._v("Netty 源码一直在更新，各版本之间有些差异，我是按照 "),e("strong",[t._v("4.1.25.Final")]),t._v(" 版本来进行介绍的。")])]),t._v(" "),e("p",[t._v("建议初学者在看完本文以后，可以去翻翻《Netty In Action》，网上也可以找到中文文字版的。")]),t._v(" "),e("h2",{attrs:{id:"准备"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[t._v("#")]),t._v(" 准备")]),t._v(" "),e("p",[t._v("学习源码，一开始肯定是准备环境。")]),t._v(" "),e("p",[t._v("我喜欢用 maven，也喜欢 Spring Boot，所以我一般先到 https://start.spring.io/ 准备一个最简单的脚手架。")]),t._v(" "),e("p",[t._v("10 秒搞定脚手架，然后就是导入到 Intellij 中，如果用新版本的 Spring Boot，可能还需要等待下载依赖，期间打开 https://mvnrepository.com/ 搜索马上要用到的 maven 依赖。")]),t._v(" "),e("p",[t._v("Netty 分为好些模块，有 "),e("a",{attrs:{href:"https://mvnrepository.com/artifact/io.netty/netty-handler",target:"_blank",rel:"noopener noreferrer"}},[t._v("netty-handler"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://mvnrepository.com/artifact/io.netty/netty-buffer",target:"_blank",rel:"noopener noreferrer"}},[t._v("netty-buffer"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://mvnrepository.com/artifact/io.netty/netty-transport",target:"_blank",rel:"noopener noreferrer"}},[t._v("netty-transport"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://mvnrepository.com/artifact/io.netty/netty-common",target:"_blank",rel:"noopener noreferrer"}},[t._v("netty-common"),e("OutboundLink")],1),t._v(" 等等，也有一个 "),e("a",{attrs:{href:"https://mvnrepository.com/artifact/io.netty/netty-all",target:"_blank",rel:"noopener noreferrer"}},[t._v("netty-all"),e("OutboundLink")],1),t._v("，它包含了所有的模块。")]),t._v(" "),e("p",[t._v("既然我们是源码分析，那么自然是用一个最简单的。netty-all 不是最好的选择，netty-example 才是：")]),t._v(" "),e("div",{staticClass:"language-xml line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-xml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("dependency")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("groupId")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("io.netty"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("groupId")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("artifactId")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("netty-example"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("artifactId")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("version")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("4.1.25.Final"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("version")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("dependency")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("p",[t._v("它不仅可以解决我们的依赖，而且 example 里面的示例非常适合我们学习使用。")]),t._v(" "),e("h2",{attrs:{id:"echo-例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#echo-例子"}},[t._v("#")]),t._v(" Echo 例子")]),t._v(" "),e("p",[t._v("Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，我们通常只要开发一个或多个 "),e("strong",[t._v("handler")]),t._v(" 用来处理我们的自定义逻辑就可以了。")]),t._v(" "),e("p",[t._v("下面，我们来看一个经常会见到的例子，它叫 "),e("strong",[t._v("Echo")]),t._v("，也就是"),e("strong",[t._v("回声")]),t._v("，客户端传过去什么值，服务端原样返回什么值。")]),t._v(" "),e("p",[t._v("打开 netty-example 的源码，把 "),e("code",[t._v("echo")]),t._v(" 包下面的代码复制出来玩一玩。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://www.javadoop.com/blogimages/netty-source/5.png",alt:"img"}})]),t._v(" "),e("p",[t._v("左边是服务端代码，右边是客户端代码。")]),t._v(" "),e("p",[t._v("上面的代码基本就是模板代码，每次使用都是这一个套路，唯一需要我们开发的部分是 "),e("code",[t._v("handler(…)")]),t._v(" 和 "),e("code",[t._v("childHandler(…)")]),t._v(" 方法中指定的各个 handler，如 "),e("code",[t._v("**EchoServerHandler**")]),t._v(" 和 "),e("code",[t._v("**EchoClientHandler**")]),t._v("，当然 Netty 源码也给我们提供了很多的 "),e("code",[t._v("handler")]),t._v("，比如上面的 "),e("code",[t._v("LoggingHandler")]),t._v("，它就是 Netty 源码中为我们提供的，需要的时候直接拿过来用就好了。")]),t._v(" "),e("p",[t._v("我们先来看一下上述代码中涉及到的一些内容：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("ServerBootstrap")]),t._v(" 类用于创建服务端实例，"),e("code",[t._v("Bootstrap")]),t._v(" 用于创建客户端实例。")]),t._v(" "),e("li",[t._v("两个 "),e("code",[t._v("EventLoopGroup")]),t._v(" ："),e("code",[t._v("bossGroup")]),t._v(" 和 "),e("code",[t._v("workerGroup")]),t._v("，它们涉及的是 Netty 的线程模型，可以看到服务端有两个 group，而客户端只有一个，它们就是 Netty 中的线程池。")]),t._v(" "),e("li",[t._v("Netty 中的 "),e("code",[t._v("Channel")]),t._v("，没有直接使用 Java 原生的 "),e("code",[t._v("ServerSocketChannel")]),t._v(" 和 "),e("code",[t._v("SocketChannel")]),t._v("，而是包装了 "),e("code",[t._v("NioServerSocketChannel")]),t._v(" 和 "),e("code",[t._v("NioSocketChannel")]),t._v(" 与之对应。")])]),t._v(" "),e("p",[t._v("当然，也有对其他协议的支持，如支持 UDP 协议的 "),e("code",[t._v("NioDatagramChannel")]),t._v("，本文只关心 TCP 相关的。")]),t._v(" "),e("ul",[e("li",[t._v("左边 "),e("code",[t._v("handler(…)")]),t._v(" 方法指定了一个 "),e("code",[t._v("handler（LoggingHandler）")]),t._v("，这个 "),e("code",[t._v("handler")]),t._v(" 是给服务端收到新的请求的时候处理用的。右边 "),e("code",[t._v("handler(...)")]),t._v(" 方法指定了客户端处理请求过程中需要使用的 "),e("code",[t._v("handlers")]),t._v("。")])]),t._v(" "),e("p",[t._v("如果你想在 "),e("code",[t._v("EchoServer")]),t._v(" 中也指定多个 "),e("code",[t._v("handler")]),t._v("，也可以像右边的 "),e("code",[t._v("EchoClient")]),t._v(" 一样使用 "),e("code",[t._v("ChannelInitializer")])]),t._v(" "),e("ul",[e("li",[t._v("左边 "),e("code",[t._v("childHandler(…)")]),t._v(" 指定了 "),e("code",[t._v("childHandler")]),t._v("，这边的 "),e("code",[t._v("handlers")]),t._v(" 是给新创建的连接用的，我们知道服务端 "),e("code",[t._v("ServerSocketChannel")]),t._v(" 在 "),e("code",[t._v("accept")]),t._v(" 一个连接以后，需要创建 "),e("code",[t._v("SocketChannel")]),t._v(" 的实例，"),e("code",[t._v("childHandler(…)")]),t._v(" 中设置的 "),e("code",[t._v("handler")]),t._v(" 就是用于处理新创建的 "),e("code",[t._v("SocketChannel")]),t._v(" 的，而不是用来处理 "),e("code",[t._v("ServerSocketChannel")]),t._v(" 实例的。")]),t._v(" "),e("li",[e("code",[t._v("pipeline")]),t._v("："),e("code",[t._v("handler")]),t._v(" 可以指定多个（需要上面的 "),e("code",[t._v("ChannelInitializer")]),t._v(" 类辅助），它们会组成了一个 "),e("code",[t._v("pipeline")]),t._v("，它们其实就类似拦截器的概念，现在只要记住一点，每个 "),e("code",[t._v("NioSocketChannel")]),t._v(" 或 "),e("code",[t._v("NioServerSocketChannel")]),t._v(" 实例内部都会有一个 "),e("code",[t._v("pipeline")]),t._v(" 实例。"),e("code",[t._v("pipeline")]),t._v(" 中还涉及到 "),e("code",[t._v("handler")]),t._v(" 的执行顺序。")]),t._v(" "),e("li",[e("code",[t._v("ChannelFuture")]),t._v("：这个涉及到 Netty 中的异步编程，和 JDK 中的 "),e("code",[t._v("Future")]),t._v(" 接口类似。")])]),t._v(" "),e("p",[t._v("对于不了解 Netty 的读者，也不要有什么压力，我会一一介绍它们，本文主要面向新手，我觉得比较难理解或比较重要的部分，会花比较大的篇幅来介绍清楚。")]),t._v(" "),e("p",[t._v("上面的源码中没有展示消息发送和消息接收的处理，此部分我会在介绍完上面的这些内容以后再进行介绍。")]),t._v(" "),e("p",[t._v("下面，将分块来介绍这些内容。鉴于读者对 NIO 或 Netty 的了解程度可能参差不齐，为了照顾初学者，很多地方需要啰嗦一些，所以希望读者一节一节往下看，对于自己熟悉的内容可以适当看快一些。")])])}),[],!1,null,null,null);e.default=v.exports}}]);