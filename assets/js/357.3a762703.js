(window.webpackJsonp=window.webpackJsonp||[]).push([[357],{707:function(s,e,n){"use strict";n.r(e);var a=n(0),t=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("我们在febs-auth定义的令牌有效时间为86400秒（即24小时），过了24小时候令牌就失效了。假如令牌即将要失效时，用户还在使用系统，那么用户的某个操作可能进行了一半时，系统突然弹出登录过期提示，非常影响用户体验。")]),s._v(" "),e("p",[s._v("要解决上面的问题，我们可以在令牌将要失效时，判断用户是否还在使用系统，如果是的话，我们可以偷偷地通过刷新令牌来获取一个新的访问令牌，存储到浏览器内存中。这样就可以在用户无感知的情况下，“延长”访问令牌的有效时间。")]),s._v(" "),e("p",[s._v("因为我们系统的请求都是通过6.1节封装的Axios对象来完成的，并且我们在request.js里配置了请求拦截，所以我们刷新令牌的动作也可以在请求拦截器里完成，大致步骤如下图所示：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://s2.ax1x.com/2019/08/28/mH8sDP.png",alt:"160.png"}})]),s._v(" "),e("p",[s._v("根据这个流程图，我们通过代码来实现。在request.js的请求拦截器里添加如下代码：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("service.interceptors.request.use(\n  config => {\n    let _config = config\n    try {\n      const expireTime = getExpireTime()\n      if (expireTime) {\n        const left = expireTime - new Date().getTime()\n        const refreshToken = getRefreshToken()\n        if (left < 5 * 60 * 1000 && refreshToken) {\n          _config = queryRefreshToken(_config, refreshToken)\n        } else {\n          if (getToken()) {\n            _config.headers['Authorization'] = 'bearer ' + getToken()\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e)\n    }\n    return _config\n  },\n  error => {\n    console.log(error)\n    return Promise.reject(error)\n  }\n)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br")])]),e("p",[s._v("上面代码中，我们在请求拦截器里判断当前时间和令牌过期时间间隔是否小于5分钟并且刷新令牌是否存在。当两个条件都满足的时候，我们就发送刷新令牌请求，否则直接在请求头中携带令牌发送请求。刷新令牌的逻辑定义在"),e("code",[s._v("queryRefreshToken")]),s._v("函数中，代码如下所示：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("async function queryRefreshToken(config, refreshToken) {\n  const result = await request.refresh('auth/oauth/token', {\n    refresh_token: refreshToken\n  })\n  if (result.status === 200) {\n    saveData(result.data)\n    config.headers['Authorization'] = 'bearer ' + getToken()\n  }\n  return config\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])]),e("p",[s._v("逻辑较为简单，就是通过刷新令牌发送令牌刷新请求，请求成功后，通过"),e("code",[s._v("saveData")]),s._v("将新的令牌保存到浏览器内存中，这个过程和登录成功后保存令牌是一样的。"),e("code",[s._v("saveData")]),s._v("代码如下所示：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function saveData(data) {\n  store.commit('account/setAccessToken', data.access_token)\n  store.commit('account/setRefreshToken', data.refresh_token)\n  const current = new Date()\n  const expireTime = current.setTime(current.getTime() + 1000 * data.expires_in)\n  store.commit('account/setExpireTime', expireTime)\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("p",[s._v("保存令牌后，我们在请求头中携带新的令牌，然后发送请求。值得注意的是，我们定义的"),e("code",[s._v("queryRefreshToken")]),s._v("方法是一个同步方法，这是因为：Axios请求是异步的，当我们发送令牌刷新请求时，可能别的Axios请求也在执行，而这时候令牌并没有更换完成，别的Axios请求可能会因令牌的过期而抛出401异常。设置为同步方法后，只有当新的令牌获取成功后，别的Axios请求才会继续执行，由于令牌刷新过程是非常快的，所以用户并不会有明显的感知。")])])}),[],!1,null,null,null);e.default=t.exports}}]);